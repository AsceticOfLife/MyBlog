---
title: 【代码随想录】数组
keywords: '代码随想录, 数组'
categories:
  - 代码随想录
tags:
  - 刷题记录
  - 代码随想录
  - C++
abbrlink: 1049654118
date: 2023-11-24 09:23:52
---

### 前言

二刷《代码随想录》数组部分，在第一遍的基础上完善解题思路、补充代码注释、补充算法复杂度分析、查看其它优秀题解。

<!--more-->

### 数组理论基础

**数组是存放在连续内存空间上的相同类型数据的集合。**

数组可以方便的通过下标索引的方式获取到下标下对应的数据，所以存取操作时间复杂度为O(1)。

插入和删除操作时间复杂度为O(n)，需要移动其它元素。

注意，在C++中使用vector时，底层实现仍然是一段连续空间，只不过对于插入和删除操作存在空间自动管理，要熟知自动管理的大致过程。

### 二分查找

**704.二分查找**

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

思路1：如果逐个比较，时间复杂度就是O(n)。并且逐个比较的思路没有使用到“升序”这个特征。

思路2：由于是有序的序列，因此可以尝试使用二分查找。二分查找每次在一段有序序列中查找，即[left, right]。

让目标target与中间下标进行比较，mid = left + (right - left) >> 2。

如果mid下标对应值大于target，由于是有序序列，小于mid下标对应值的元素都在左边，说明下面应该在[left, mid - 1]中查找；否则应该在[mid + 1, right]中继续查找。

注意这里每次查找都是左闭右闭区间，最后的终止条件应该是left大于right，即使left == right，那么mid可以为left==right，仍然可以查找。

（除2可以用右移1表示）

代码如下：

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1; // [left, right]
        while (left <= right) {
            int mid = left + ((right - left) >> 1); // the mid index
            int tmp = nums[mid]; // temp target
            if (tmp == target) return mid;
            else if (tmp > target) right = mid - 1; // update right
            else left = mid + 1; // update left
        }

        return -1; // fail to find
    }
};
```

PS：第二种写法，上面是左闭右闭区间，下面使用左闭右开区间。即每次查找的区间是[left, right)，中间下标仍然是mid。不同的地方在于：如果mid对应的值大于target，此时下次查找的区间应该是[left, mid)，即令right = mid；否则下次查找的区间应该是[mid + 1, right)。还需要注意的是终止条件，终止条件是left == right，此时下标为不在范围内的right。

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1; // [left, right]
        while (left <= right) {
            int mid = left + ((right - left) >> 1); // the mid index
            if (nums[mid] == target) return mid;
            else if (nums[mid] > target) right = mid - 1; // update right
            else left = mid + 1; // update left
        }

        return -1; // fail to find
    }
};
```



**相关题目：**

35.搜索插入位置：二分查找法如果查找失败的话就是应该插入的位置。

```c++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1; // 使用左闭右闭区间表示
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] > target) right = mid - 1;
            else if (nums[mid] < target) left = mid + 1;
            else return mid;
        }

        // 循环结束时left == right + 1
        return left;
    }
};
```

34.在排序数组中查找元素的第一个和最后一个位置：相等时继续向左区间找，最终结果就是左边界，继续向右找就是右边界。
找到左右边界之后需要判断边界是否合理。

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> result(2, -1);
        
        // 第一部分：寻找左边界
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target) {
                right = mid - 1;
                result[0] = mid;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        // 循环结束之后左边界要么是没有被赋值，要么是左边界，一定是合法范围

        // 第二部分：寻找右边界
        left = 0;
        right = nums.size() - 1;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            if (nums[mid] == target) {
                left = mid + 1;
                result[1] = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        // 循环结束之后，右边界要么没有被赋值，要么就是右边界，不会超过数组范围

        // 找到左右边界之后需要进行判断是否合理
        // 左右边界只能是未被赋值或者找到target时的赋值
        if (result[0] == -1 || result[1] == - 1)
            result[0] = result[1] = -1;
        return result;
    }
};
```

69.x 的平方根：$\sqrt{x}$使用二分法搜索表示为:$k^2\le x$，即在[0, x]中搜索最大的整数值，即右边界

两个int值相乘的取值范围会超过int，应该使用long long。

```c++
class Solution {
public:
    int mySqrt(int x) {
        int left = 0, right = x;
        int result = -1;
        while (left <= right) {
            long long mid = left + ((right - left) >> 1);
            long long tmp = mid * mid;
            if (tmp <= x) {
                left = mid + 1;
                result = mid;
            } else {
                right = mid - 1;
            }
        }

        return result;
    }
};
```

367.有效的完全平方数：在[0,num]范围内搜索

```c++
class Solution {
public:
    bool isPerfectSquare(int num) {
        int left = 0, right = num;
        while (left <= right) {
            long long mid = left + ((right - left) >> 1);
            long long tmp = mid * mid;
            if (tmp == num) return true;
            else if (tmp < num) left = mid + 1;
            else right = mid - 1;
        }

        return false;
    }
};
```





### 移除元素

**27.移除元素**：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**思路1：**遍历所有元素（时间复杂度为O(n)），当遇到与val相等的元素时，后面所有元素向前移动一个位置，也就是删除操作（时间复杂度O(n)）。因此总的时间复杂度是O(n^2)。

**思路2：**采用双指针法，快指针fast和慢指针slow，最开始快慢指针指向开始的位置。遍历所有元素。
慢指针指向的始终是下一个应该保留的元素的位置，也就是最终长度。
判断快指针fast指向的元素，如果该元素与val相等，说明应该是被删除的元素，此时快指针向后移动；
如果该元素与val不相等，说明是应该保留的元素，将其移动到慢指针slow指向的位置，并且快慢指针均向后移动。

时间复杂度O(n)，遍历一次数组；空间复杂度O(1)

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow, fast, len;
        slow = fast = 0; // 快慢指针
        len = nums.size();
        while (fast < len) {
            if (nums[fast] == val) {
                // 找到应该被删除的元素
                // 不将其移动到保留元素的位置
                fast++;
            } else {
                // 应该保留的元素移动到保留位置
                nums[slow] = nums[fast];
                slow++;
                fast++;
            }
        }

        return slow;
    }
};
```



**相关题目：**

26.删除排序数组中的重复项：快慢指针，当快指针元素等于慢指针元素时，就一直向后移动；不等时就让慢指针的下一个元素等于快指针元素，并且快慢指针同时递增。
慢指针始终指向最后一个元素，所以最终长度应该是慢指针加1.

```c++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int len = nums.size();
        if (len == 0) return 0;

        int slow, fast;
        slow = fast = 0;
        while (fast < len) {
            if (nums[slow] != nums[fast]) nums[++slow] = nums[fast];
            ++fast;
        }

        return slow + 1;
    }
};
```

时间复杂度O(n)，所有元素被遍历1次；时间复杂度O(1)



283.移动零：相当于遇到val为0就删除，最后在数组后面全部赋值为0.

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow, fast;
        slow = fast = 0;
        int len = nums.size();

        // 将所有值为0的元素删除
        while (fast < len) {
            if (nums[fast] != 0) nums[slow++] = nums[fast];
            fast++;
        }
        // 将后面的元素都赋值为0
        for (; slow < len; slow++) nums[slow] = 0;
    }
};
```

时间复杂度O(n)，每个元素遍历一次；空间复杂度O(1)



844.比较含退格的字符串：
思路1：先对字符串s删除退格字符，再对字符串t删除退格字符，最后比较两个字符。

```c++
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int s_len = s.length();
        int t_len = t.length();
        int slow1, fast1;

        // 处理s中的退格
        slow1 = fast1 = 0;
        while (fast1 < s_len) {
            if (s[fast1] != '#') {
                // slow指向的位置为fast的字符
                s[slow1++] = s[fast1];
            } else {
                // 如果是#慢指针后移一位
                slow1 == 0? slow1 : slow1--;
            }

            fast1++;
        }
        // 处理完成之后slow就是s串后一位

        // 处理t中的退格
        int slow2, fast2;
        slow2 = fast2 = 0;
        while (fast2 < t_len) {
            if (t[fast2] != '#') {
                // slow指向的位置为fast的字符
                t[slow2++] = t[fast2];
            } else {
                // 如果是#慢指针后移一位
                slow2 == 0 ? slow2 : slow2--;
            }
            
            fast2++;
        }

        // 比较两个字符
        if (slow1 != slow2) return false;
        for (int i = 0; i < slow1; i++) {
            if (s[i] != t[i]) return false;
        }

        return true;
    }
};
```

时间复杂度O(N + M)，分别遍历一次串s和串t，再比较一次串s和t；空间复杂度O(1)

思路2：由于遇到#应该前移，假如比较完前面的字符遇到#则已经比较过的字符没有意义，所以不能从前向后比较，因此考虑逆序比较。
这里的误区是：遇到#不应该立即向前移动，因为#前面仍然可能是#。
所以采取的方式为：del_count（表示应该删除的字符）初始值为0，当遇到#时，则del_count应该加1；当遇到普通字符时，如果del_count为0，那么不需要删除，如果不为0，则当前字符应该删除，并且del_count减1。

```c++
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        int i, j; // 分别表示两个字符串的下标
        i = s.length() - 1;
        j = t.length() - 1;

        int skips = 0, skipt = 0;

        // 两个指针只要有一个有效就需要进行循环
        // 循环中处理不相等情况
        while (i >= 0 || j >= 0) {
            // 处理退格字符
            // 令指针指向第一个不等于#的字符
            while (i >= 0) {
                if (s[i] == '#') {
                    // 遇到#需要删除的字符计数加1
                    skips++;
                    i--;
                } else {
                    // 遇到普通字符
                    // 如果需要删除的字符数目大于0则跳过一个字符
                    // 否则当前字符就是不应该被删除的字符
                    // 跳出循环
                    if (skips > 0) {
                        i--;
                        skips--;
                    } else break;
                }
            }
            while (j >= 0) {
                if (t[j] == '#') {
                    skipt++;
                    j--;
                } else {
                    if (skipt > 0) {
                        j--;
                        skipt--;
                    } else break;
                }
            }
            // 上面的循环结束之后需要判断i与j是否小于0
            if (i >= 0 && j >= 0) {
                // i与j均指向合法位置
                if (s[i] != t[j]) return false;
            } else {
                // i与j已经有一个小于0
                // 如果另一个大于0
                // 说明仍存在普通字符
                if (i >= 0 || j >= 0) return false;
            }

            i--;
            j--;
        }

        return true;
    }
};
```

时间复杂度O(N + M)，但是每个字符串只遍历一次，一定比思路1简单；空间复杂度O(1)



977.有序数组的平方：思路1：双指针法，分别从开头和结尾，记录较大的值到新数组中。

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int len = nums.size();
        // 旧数组先平方
        for (int i = 0; i < len; i++) nums[i] = nums[i] * nums[i];

        vector<int> result(len, 0); // 初始化新数组
        int left = 0, right = len - 1;
        len--;

        while (left <= right) {
            if (nums[left] <= nums[right]) {
                result[len--] = nums[right];
                right--;
            } else {
                result[len--] = nums[left];
                left++;
            }
        }

        return result;
    }
};
```

时间复杂度O(n)；空间复杂度O(n)

思路2：找到负数与非负数之间的分界线，假设为flag。那么平方之后的nums[0]~nums[flag - 1]是递增的，[flag]~nums[end]也是递增的，就可以利用归并排序进行合并。

时间复杂度O(n)，找分界线为O(n)，归并排序复杂度O(n)；空间复杂度O(n)



