---
title: 【代码随想录】二叉树
keywords: '代码随想录, 二叉树'
categories:
  - 代码随想录
tags:
  - 刷题记录
  - 代码随想录
  - C++
typora-root-url: 【代码随想录】二叉树
abbrlink: 1225167916
date: 2024-01-16 10:26:57
---

### 二叉树简介

基础概念：满二叉树、完全二叉树、二叉查找树（搜索树）、平衡二叉搜索树

**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

二叉树存储结构：顺序存储（如果双亲结点是i那么左孩子是2\*i + 1，右孩子是2\*i + 2)和链式存储

二叉树的遍历方式：

- 深度优先遍历

  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）

- 广度优先遍历

  - 层次遍历（迭代法）

  **栈其实就是递归的一种实现结构**，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。

  广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

  二叉树节点定义：

  ```c++
  struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };
  ```

<!-- more -->

### 二叉树递归遍历

递归的方法：

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

144.二叉树的前序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void PreTraversal(TreeNode *cur, vector<int> &result) {
        // 终止条件
        if (cur == nullptr) return;

        // 首先处理当前根节点
        result.push_back(cur->val);
        // 然后处理左右孩子节点
        PreTraversal(cur->left, result);
        PreTraversal(cur->right, result);
    }

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result; // 结果数组
        PreTraversal(root, result);
        
        return result;
    }
};
```

另一种写法：在进入递归之前就判断是否为空结点。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void PreTraversal(TreeNode *cur, vector<int> &result) {
        // 终止条件
        // 空结点不会进入该函数

        // 首先处理当前根节点
        result.push_back(cur->val);
        // 然后处理左右孩子节点
        if (cur->left) PreTraversal(cur->left, result);
        if (cur->right) PreTraversal(cur->right, result);
    }


    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result; // 结果数组
        if (root) PreTraversal(root, result);
        
        return result;
    }
};
```

145.二叉树的后序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void PostTraversal(TreeNode *cur, vector<int> &result) {
        // 终止条件
        if (cur == nullptr) return;

        // 先处理左右孩子
        PostTraversal(cur->left, result);
        PostTraversal(cur->right, result);

        // 最后处理当前根节点
        result.push_back(cur->val);
    }

    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        PostTraversal(root, result);

        return result;
    }
};
```



94.二叉树的中序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void InTraversal(TreeNode *cur, vector<int> &result) {
        // 终止条件
        if (cur == nullptr) return;

        // 先处理左孩子
        InTraversal(cur->left, result);

        // 接着处理当前根节点
        result.push_back(cur->val);

        // 最后处理右孩子
        InTraversal(cur->right, result);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        InTraversal(root, result);

        return result;
    }
};
```



### 二叉树迭代遍历

前序遍历：使用栈实现

前序处理的方式是：根、左、右，因此向将根节点放入栈、右孩子进入栈、最后左孩子进入栈。

（注意这里为了减少将节点从栈中拿出还需要判断是否为空节点的操作，空结点不入栈，对应了上面的前序遍历第二种写法，在入栈前判断左右孩子是否为空）

一次循环所做的操作与一次递归函数基本类似，先处理从栈中取出的根节点，然后将右、左孩子入栈。

注意访问顺序和处理顺序，访问顺序就是第一次遇到这个节点，处理顺序是真正操作节点的值val。

**访问和处理的顺序是一致的。**前序遍历的访问顺序是中左右，处理的顺序也是中左右。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode *> st; // 用于存放节点
        vector<int> result;

        if (root) st.push(root);
        while (!st.empty()) {
            // 首先取出栈顶节点
            TreeNode *cur = st.top();
            st.pop();
            // 处理栈顶节点
            result.push_back(cur->val);

            // 访问左右孩子节点，注意顺序
            if (cur->right) st.push(cur->right);
            if (cur->left) st.push(cur->left);
        }

        return result;
    }   
};
```



中序遍历：处理顺序是中左右，但是**访问顺序**是一直访问到左孩子结点为空时才会处理中结点，接着以右孩子作为新的根结点进行访问。

因此借助指针来**访问**，使用栈**处理**。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode *> st; // 处理节点顺序
        vector<int> result;
        TreeNode *cur = root; // 访问节点顺序
        // 当访问节点为空并且栈空时所有节点都已处理
        while (cur != nullptr || !st.empty()) {
            if (cur != nullptr) {
                // 当前访问节点不是空结点
                st.push(cur);
                // 继续向左访问
                cur = cur->left;
            } else {
                // 当前访问节点是空结点
                // 说明向左访问到头
                // 处理根节点
                cur = st.top();
                st.pop();
                result.push_back(cur->val);

                // 接着访问右孩子
                cur = cur->right;
            }
        } // end while

        return result;
    }
};
```

后序遍历：

将前序遍历稍微修改：前序遍历是中左右->中右左->逆序->左右中

即逆序。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode *> st;
        vector<int> result;
        if (root) st.push(root);
        while (!st.empty()) {
            TreeNode *cur = st.top();
            st.pop();
            // 处理顺序改为中、右、左
            result.push_back(cur->val);

            // 先左后右入栈，这样处理的时候就是先右后左
            if (cur->left) st.push(cur->left);
            if (cur->right) st.push(cur->right);
        }
        // 逆序处理
        reverse(result.begin(), result.end());

        return result;
    }
};
```

### 二叉树统一迭代法

以中序遍历为例，**将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**要处理的结点放入栈之后，需要加上一个空结点。

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode *> st;
        vector<int> res;

        // 根节入栈
        if (root != nullptr) st.push(root);

        while (!st.empty()) {
            TreeNode *node = st.top();
			
            // 非空节点进行访问操作
            if (node != nullptr) {
                // 先将这个结点弹出
                st.pop();

                // 尝试将右孩子入栈
                if (node->right != nullptr) st.push(node->right);
                // 将中结点入栈，并且中间结点已经访问过，作为下一次处理的结点需要标记
                st.push(node);
                st.push(nullptr);

                // 最后将左孩子入栈
                if (node->left != nullptr) st.push(node->left);
            } else {
                // 如果栈顶是空指针，说明下一个是需要处理的结点
                st.pop();

                // 将需要处理的结点假如列表
                res.push_back(st.top()->val);
                st.pop();
            }
        }

        return res;
    }
};
```

前序遍历：

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        // 使用栈保存未访问的结点
        stack<TreeNode *>st;
        vector<int> res;

        if (root == nullptr) return res;
        // 首先将根结点入栈
        st.push(root);

        while (!st.empty()) {
            TreeNode *node = st.top();

            if (node != nullptr) {
                st.pop();

                // 右、左孩子入栈
                if (node->right) st.push(node->right);
                if (node->left) st.push(node->left);
                
                st.push(node);
                st.push(nullptr);
            } else {
                st.pop();
                res.push_back(st.top()->val);
                st.pop();
            }
        }

        return res;
    }
};
```

后序遍历：

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        // 使用栈保存未访问的结点
        stack<TreeNode *>st;
        vector<int> res;

        if (root == nullptr) return res;
        // 首先将根结点入栈
        st.push(root);

        while (!st.empty()) {
            TreeNode *node = st.top();

            if (node != nullptr) {
                st.pop();
                st.push(node);
                st.push(nullptr);
                
                // 左、右孩子入栈
                if (node->left) st.push(node->left);
                if (node->right) st.push(node->right);
            } else {
                st.pop();
                res.push_back(st.top()->val);
                st.pop();
            }
        }

        return res;
    }
};
```



### 二叉树层序遍历

层序遍历就是每次从左到右遍历同一个深度的节点，类似于广度优先搜索，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**

思路1：(类比于上面的迭代法中使用空指针作为标记)是为每层后面加一个空结点标识，当遇到空结点说明上一层处理完了，同时也要在队列中加一个空结点标识现在队列中是一层。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        vector<int> temp;
        queue<TreeNode *> qu;
        // 每一层用一个空结点区分
        if (root != nullptr) {
            qu.push(root);
            qu.push(nullptr);
        } 
        
        while (qu.size() > 1 || qu.front() != nullptr) {
            // 取出队首元素
            TreeNode *node = qu.front();
            if (node != nullptr) {
                // 不为空层数不增加
                qu.pop();

                // 处理结点
                temp.push_back(node->val);

                // 并尝试将左右结点队
                if (node->left) qu.push(node->left);
                if (node->right) qu.push(node->right);
            } else {
                // 当队首元素为null说明这一层已经结束
                // 层数加1
                // 并且该层的孩子们（也就是下一层）也都入队，再加一个空结点
                qu.pop();
                res.push_back(temp);
                temp = vector<int>();
                qu.push(nullptr);
            }
        }
        if (temp.size() != 0) res.push_back(temp);

        return res;
    }
};
```

作者的思路1：（迭代法）当队列不为空时，每次处理一层，使在每次循环最开始记录当前队列多少元素，即为当前层数。然后使用for循环处理这size个结点即可。

还是一样空结点不入队，否则每次取出来节点还需要判断是否为空结点。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode *> que;
        vector<vector<int>> result;
        
        if (root) que.push(root);
        while (!que.empty()) {
            int nums_layer = que.size();
            // 处理这一层的所有节点
            vector<int> temp(nums_layer); // 该层所有节点
            for (int i = 0; i < nums_layer; i++) {
                // 取出节点
                TreeNode *cur = que.front();
                que.pop();

                // 处理节点
                temp[i] = cur->val;

                // 访问左右孩子
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            // 将该层结果保存
            result.push_back(temp);
        }

        return result;
    }
};
```



作者的思路2：使用深度优先遍历，递归的方式，每次处理完根节点之后，接着递归处理左右孩子。

递归参数：当前根结点，保存访问记录的列表，当前深度（因为一层使用一个列表表示，因此需要知道当前深度应该加到哪个列表中）

递归终止条件：当前根结点为空

一层递归逻辑：处理当前根结点，接着处理左右孩子。

```c++
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth) {
        if (cur == nullptr) return;
        if (result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result, depth + 1);
        order(cur->right, result, depth + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

题目：

102.二叉树的层序遍历

与上面的代码一样



107.二叉树的层次遍历II

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

思路：自上而下层序遍历之后逆序。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode *> que;
        vector<vector<int>> result;
        // 层序遍历
        if (root) que.push(root);
        while (!que.empty()) {
            int layer_nums = que.size(); // 该层节点数目
            vector<int> layer_vals(layer_nums); // 当前一层所有节点
            for (int i = 0; i < layer_nums; i++) {
                TreeNode *cur = que.front();
                que.pop();
                // 处理当前根节点
                layer_vals[i] = cur->val;

                // 左右孩子入队
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            // 将当前一层存储
            result.push_back(layer_vals);
        }
        reverse(result.begin(), result.end());

        return result;
    }
};
```



199.二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<img src="199.tree.jpg" alt="199.tree" style="zoom:67%;" />

```c++
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

思路：右视图就是层序遍历的每一层最后一个元素。

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> result;
        // 层序遍历
        if (root)
            que.push(root);
        while (!que.empty()) {
            int layer_nums = que.size(); // 该层节点数目

            layer_nums--; // 剩余最后一个元素
            for (int i = 0; i < layer_nums; i++) {
                TreeNode* cur = que.front();
                que.pop();
                // 处理当前根节点
                // 什么都不做

                // 左右孩子入队
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            // 将最后一个元素保留
            TreeNode* cur = que.front();
            que.pop();
            result.push_back(cur->val);
            // 左右孩子入队
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }

        return result;
    }
};
```



637.二叉树的层平均值

给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。

思路：层序遍历求每一层的平均值。

需要注意的是值的范围。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode *> que;
        vector<double> result;
        // 层序遍历
        if (root) que.push(root);
        while (!que.empty()) {
            int layer_nums = que.size(); // 该层节点数目
            double sum = 0; // 该层总和
            for (int i = 0; i < layer_nums; i++) {
                TreeNode *cur = que.front();
                que.pop();
                // 处理当前根节点
                sum += cur->val;

                // 左右孩子入队
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            // 将当前一层平均值存储
            result.push_back(sum / layer_nums);
        }

        return result;
    }
};
```



429.N叉树的层序遍历

给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。

思路：与层序遍历基本相同，唯一区别是每个节点的孩子入队时，将N个节点都入队。

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        queue<Node *> que;
        vector<vector<int>> result;
        // 层序遍历
        if (root) que.push(root);
        while (!que.empty()) {
            int layer_nums = que.size(); // 该层节点数目

            vector<int> layer_vals(layer_nums); // 当前一层所有节点
            for (int i = 0; i < layer_nums; i++) {
                Node *cur = que.front();
                que.pop();
                // 处理当前根节点
                layer_vals[i] = cur->val;

                // 所有孩子入队
                for (Node *child : cur->children) 
                    if (child) que.push(child);

            }
            // 将当前一层存储
            result.push_back(layer_vals);
        }

        return result;
    }
};
```

515.在每个树行中找最大值

思路：层序遍历每一行求最大值。与求平均值类似。



116.填充每个节点的下一个右侧节点指针

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

<img src="116.png" alt="116" style="zoom:50%;" />

思路：层序遍历会取出每一层所有的节点，因此除了对第一个的处理是保存当前next指针外，其余均零上一个的next指针指向自己并更新指针。每一层循环结束令最后一个节点的next指针指向空。

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        queue<Node *> que;
        if (root) que.push(root);
        // 层序遍历二叉树
        while (!que.empty()) {
            int layer_nums = que.size();
            
            // 对本层第一个特殊处理
            Node *cur = que.front();
            que.pop();
            Node **pre = &(cur->next); // 保存指向next指针的指针
            // 当前节点左右孩子入队
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
            --layer_nums;

            // 处理剩下的节点
            while (layer_nums--) {
                cur = que.front();
                que.pop();
                // 令前一个节点的next指针指向当前节点
                *pre = cur;
                // 更新前一个节点的next指针为当前节点的next指针
                pre = &(cur->next);

                // 当前节点左右孩子入队
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            // 处理最后一个节点的next指针
            *pre = nullptr;
        }

        return root;
    }
};
```



117.填充每个节点的下一个右侧节点指针II

给定一个二叉树：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。

初始状态下，所有 next 指针都被设置为 `NULL` 。

思路：这道题与上一题的区别是：上一题是完美二叉树。对于完美二叉树来说，其节点位置都是可以预知的。本题使用层序遍历依然可解。



104.二叉树的最大深度

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

思路：第一层也就是根节点所在一层的深度是1，下面每增加一层深度加1。其实可以看作是层序遍历的每一层的次数。因此每增加一层加1即可。

这里不再给出代码。



111.二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

思路：上一题必须遍历完所有的节点才能知道谁是最远的叶子节点，该题层序遍历时由近及远进行遍历，只要当前层有叶子节点就可以提前返回当前层数。

具体实现就是：与上一题一样使用一个变量记录当前层数，然后在处理当前节点时，如果左右孩子均为空（说明是叶子节点）立即返回当前层数。

### 翻转二叉树

题目：226

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

<img src="226.jpg" alt="226" style="zoom:50%;" />

思路：遍历左右结点，把节点的左右孩子互换即可。

层序遍历可以实现。

递归法：前序、后序遍历都可以，中序遍历不可以，这是因为中序先处理左孩子，再处理中间节点，处理中间结点时左右孩子互换，如果再处理右孩子那么右孩子是之前处理的左孩子。

迭代法：前、中、后序遍历都可以。这里的中序遍历可以是因为采用标记法处理节点时，即使处理的是中间节点，互换了左右孩子，下一次处理的节点是从栈中取出，不用担心因当前节点互换影响处理顺序。

这里给出迭代法的中序遍历。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode *> st;
        if (root) st.push(root);

        // 采用中序法遍历
        // 应该处理的节点后面是一个空结点
        while (!st.empty()) {
            TreeNode *cur = st.top();
            st.pop();
            if (cur != nullptr) {
                // 如果不是空结点说明应该遍历
                if (cur->right) st.push(cur->right);

                // 添加中间节点和一个空结点
                // 表示下一次应该处理
                st.push(cur);
                st.push(nullptr);

                if (cur->left) st.push(cur->left);
            } else {
                // 如果是空结点说明栈顶是应该处理的节点
                cur = st.top();
                st.pop();
                // 交换左右节点
                swap(cur->left, cur->right);
            }
        }

        return root;
    }
};
```



### 阶段总结1

该部分首先介绍一下内容：

二叉树基本概念：包括满满二叉树、完全二叉树，以及二叉树的存储结构，定义方式等。

二叉树前中后递归遍历方法

二叉树前中后迭代遍历方法：由于中序遍历的访问和处理是不一致的（总是先访问到中间结点，才会访问左右孩子，但是处理的时候是先处理左孩子，再处理中间结点），所以需要一个标志（标识应该被处理）。后序遍历就是前序遍历稍微修改一下：中左右->中右左 这样范围访问之后再逆序即可。

二叉树前中后统一迭代遍历方法

二叉树层序遍历方法

### 对称二叉树

101.对称二叉树

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

（这里的意思其实就是检查一个二叉树是否关于中轴对称）

思路1：（递归法）不是比较左右结点，而是比较左右子树的外侧和里侧，令左子树的左孩子与右子树的右孩子比较，左子树的右孩子与右子树的左孩子比较。

递归的方式：

1.递归返回值和参数：参数为两个结点，返回值是bool

2.递归终止条件：这两个结点存在空结点的情况和不存在空结点的情况

3.递归的逻辑：首先排除两个树的根节点为空结点情况和均不是空结点但是不相等的情况，剩下的就是两个结点都不为空并且相等。接着外侧和里侧孩子进行比较。

```c++
class Solution {
public:
    // 比较两个子树是否对称
    bool compare(TreeNode *left, TreeNode *right) {
        if (left == nullptr && right == nullptr) return true;
        else if (left != nullptr && right == nullptr) return false;
        else if (left == nullptr && right != nullptr) return false;
        else if (left->val != right->val) return false;

        // 比较完根节点之后开始比较孩子
        bool outside = compare(left->left, right->right);
        bool inside = compare(left->right, right->left);

        return outside && inside;
    }

    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) return true;
        return compare(root->left, root->right);
    }
};
```



思路2：（迭代法）使用队列，队列里面的每两个相邻的结点是要比较的两个结点。

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        queue<TreeNode *> que; // 队列
        if (root == nullptr) return true;
        que.push(root->left);
        que.push(root->right);
        // 队列中每两个为一组是需要进行比较的两个子树的根节点
        while (!que.empty()) {
            TreeNode *left = que.front(); que.pop();
            TreeNode *right = que.front(); que.pop();

            // 首先判断两个根节点是否满足条件
            if (left == nullptr && right == nullptr) continue;
            else if (left == nullptr && right != nullptr) return false;
            else if (left != nullptr && right == nullptr) return false;
            else if (left->val != right->val) return false;

            // 经过上面的判断之后此时可以确定两个子树的根节点不为空且val相等
            // 将需要进行比较的两个节点放在一起
            que.push(left->left);
            que.push(right->right);

            que.push(left->right);
            que.push(right->left);
        }

        return true;
    }
};
```

思路3：使用栈也是一样的。



题目：

100.相同的树

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

思路：采取相同的方式遍历两个树，依次比较两个节点

1.递归法：

递归的参数和返回值：参数为两个需要进行比较的树的根节点，返回值为bool

递归的终止条件：根节点进行比较，如果两个根节点都是空，那么返回true；如果一个为空另一个不为空，返回false；如果两个节点的值不同，返回空；剩下就是比较子树

递归逻辑：终止条件中已经比较了两个树的根，接下来分别比较左孩子和右孩子。

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == nullptr && q == nullptr) return true;
        else if (p != nullptr && q == nullptr) return false;
        else if (p == nullptr && q != nullptr) return false;
        else if (p->val != q->val) return false;

        // 经过上面的比较两个根已经相同
        // 比较两棵树的左孩子
        bool left_flag = isSameTree(p->left, q->left);
        bool right_flag = isSameTree(p->right, q->right);

        return left_flag && right_flag;
    }
};
```

2.迭代法：使用一个队列保存每次需要进行比较的两个节点。

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        queue<TreeNode *> que;
        que.push(p);
        que.push(q);
        // 每次分别迭代两棵树的一个节点
        while (!que.empty()) {
            TreeNode *left_node = que.front(); que.pop();
            TreeNode *right_node = que.front(); que.pop();

            if (left_node == nullptr && right_node == nullptr) continue;
            else if (left_node != nullptr && right_node == nullptr) return false;
            else if (left_node == nullptr && right_node != nullptr) return false;
            else if (left_node->val != right_node->val) return false;

            // 经过上面的比较两个节点已经相同
            // 遍历各自的左孩子
            que.push(left_node->left);
            que.push(right_node->left);

            // 遍历各自的右孩子
            que.push(left_node->right);
            que.push(right_node->right);
        }

        return true;
    }
};
```

572.另一个树的子树

给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。

思路1：遍历root的每一个节点，分别作为子树，与subRoot进行比较。

两颗子树进行比较的方法在上一题中已经给出，因此这里只需要在外层增加遍历root即可。

这里采用层序遍历。

```c++
class Solution {
public:
    // 判断两棵树是否完全相同
    bool isSameTree(TreeNode* p, TreeNode* q) {
        queue<TreeNode *> que;
        que.push(p);
        que.push(q);
        // 每次分别迭代两棵树的一个节点
        while (!que.empty()) {
            TreeNode *left_node = que.front(); que.pop();
            TreeNode *right_node = que.front(); que.pop();

            if (left_node == nullptr && right_node == nullptr) continue;
            else if (left_node != nullptr && right_node == nullptr) return false;
            else if (left_node == nullptr && right_node != nullptr) return false;
            else if (left_node->val != right_node->val) return false;

            // 经过上面的比较两个节点已经相同
            // 遍历各自的左孩子
            que.push(left_node->left);
            que.push(right_node->left);

            // 遍历各自的右孩子
            que.push(left_node->right);
            que.push(right_node->right);
        }

        return true;
    }

    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        queue<TreeNode *> que;
        if (root) que.push(root); // 空结点不入栈

        // 层序遍历
        while (!que.empty()) {
            int layer_size = que.size(); // 本层节点个数
            // 访问本层所有节点
            while (layer_size--) {
                TreeNode *cur = que.front(); que.pop();

                // 访问节点
                if (isSameTree(cur, subRoot)) return true;

                // 左右孩子入队
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        }

        return false;
    }
};
```

思路2：不管是使用哪种方式遍历树，实际上最终把每个节点都访问一次，因此可以将树看作是一个节点序列；

采用同样的方式遍历subRoot，那么subRoot也是一个序列。

因此这里就相当于判断subRoot是否为root序列的一个子序列，类似于字符串的模式匹配，可以采用KMP算法。





### 二叉树的最大深度

题目：104、

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。



思路1：递归法，

前序遍历递归法

1.递归的参数、返回值：参数是当前子树的根节点，和当前子树根节点的深度，即根节点到当前子树根节点的节点数。无返回值

2.递归的终止条件：当遇到空结点时，返回

3.递归的逻辑：在最开始应该使用一个全局变量记录最大深度，然后判断当前递归传进来的参数（即当前子树根节点的深度是否为更大的深度），然后尝试递归左孩子和右孩子

```c++
class Solution {
public:
    int result;

    void GetDepth(TreeNode *cur, int depth) {
        // 比较当前子树节点的深度是否更大
        result = result > depth ? result : depth;

        // 递归终止
        if (cur->left == nullptr && cur->right == nullptr) return;

        // 递归左孩子
        if (cur->left) {
            depth++; // 加上左孩子深度加1
            GetDepth(cur->left, depth);
            depth--; // 回溯到当前子树根节点深度减1
        }

        if (cur->right) {
            depth++;
            GetDepth(cur->right, depth);
            depth--;
        }
    }

    int maxDepth(TreeNode* root) {
        result = 0;

        // 递归中空结点不进行递归
        if (root == nullptr) return result;

        GetDepth(root, 1);

        return result;
    }
};
```



后序遍历递归法：

1.递归的参数、返回值：参数是当前子树根节点，返回值是当前子树根节点的高度

2.递归的终止条件：当前传入的根节点为空时，返回0

3.递归的处理逻辑：先求左子树的高度，再求右子树的高度，然后当前子树的高度是二者中较大的加1

```c++
class Solution {
public:
    int GetDepth(TreeNode *cur) {
        if (cur == nullptr) return 0;

        int left_depth = GetDepth(cur->left);
        int right_depth = GetDepth(cur->right);

        return max(left_depth, right_depth) + 1;
    }

    int maxDepth(TreeNode* root) {
        return GetDepth(root);
    }
};
```



思路2：迭代法（使用层序遍历比较简单）

遍历时记录每一层的高度

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode *> que; // 存放未访问节点
        if (root) que.push(root); // 空结点不入队
        int depth = 0;
        
        while (!que.empty()) {
            // 此为新的一层
            depth++;

            // 记录该层节点数
            int layer_size = que.size();
            for (int i = 0; i < layer_size; i++) {
                // 取出节点
                TreeNode *cur = que.front();
                que.pop();

                // 尝试左右孩子入队
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        } // end when queue is empty

        return depth;
    }
};
```



收获：

本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度（前序遍历记录的是根节点到当前节点的路径条数或者节点数），使用后序求的是高度（后序遍历记录的是从叶子节点到当前节点的路径书或者节点数）。

- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）

**所以根节点的高度就是二叉树的最大深度**



题目：559 N 叉树的最大深度

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

思路：与二叉树基本一致。下面只使用层序遍历的迭代法实现。

```c++
class Solution {
public:
    int maxDepth(Node* root) {
        queue<Node *> que; // 保存未“访问”的节点
        if (root != nullptr) que.push(root);
        int depth = 0;

        // 遍历以及处理所有的节点
        while (!que.empty()) {
            // 此为新的一层
            depth++;

            // 获取当前层节点数
            int layer_size = que.size();
            for (int i = 0; i < layer_size; i++) {
                // 取出当前节点
                Node *cur = que.front();
                que.pop();

                // 将所有孩子都入队
                for (int j = 0; j < cur->children.size(); j++) {
                    if (cur->children[j] != nullptr)
                        que.push(cur->children[j]);
                }
            }
        } // end when que is empty

        return depth;
    }
};
```





### 二叉树的最小深度

题目：111

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

思路1：递归法

前序遍历从根节点记录深度，所以这里的递归使用前序。

1.递归的参数、返回值：参数是当前根节点，以及从根节点到当前根节点的节点数。无返回值

2.递归的终止条件：空结点不进行递归，所以这里不需要终止条件

3.递归的逻辑：首先判断该节点是否为叶子节点，如果是则记录此时深度并返回；然后尝试递归左孩子，接着尝试递归右孩子

```c++
class Solution {
public:
    int min_depth;

    void PreTraversal(TreeNode *cur, int depth) {
        if (cur->left == nullptr && cur->right == nullptr) {
            min_depth = min_depth > depth ? depth : min_depth;
            return;
        }

        // 尝试左孩子
        if (cur->left) PreTraversal(cur->left, depth + 1);
        // 尝试右孩子
        if (cur->right) PreTraversal(cur->right, depth + 1);
    }

    int minDepth(TreeNode* root) {
        // 空指针不递归
        if (root == nullptr) return 0;

        min_depth = INT_MAX;

        PreTraversal(root, 1);

        return min_depth;
    }
};
```



如果使用后序遍历：后序遍历记录的是子树的最小深度

题目中说的是：**最小深度是从根节点到最近叶子节点的最短路径上的节点数量。**注意是**叶子节点**。

什么是叶子节点，左右孩子都为空的节点才是叶子节点！

如果采用以下递归逻辑：

```
int leftDepth = getDepth(node->left);
int rightDepth = getDepth(node->right);
int result = 1 + min(leftDepth, rightDepth);
return result;
```

那么如果一个结点没有左孩子，那么没有左孩子的分支就会作为最小深度。

正确逻辑应该是：

如果左子树为空，右子树不为空，说明最小深度是 1 + 右子树的深度。

反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的深度。

 最后如果左右子树都不为空，返回左右子树深度最小值 + 1 。

思路2：使用迭代方式的层序遍历。只要遇到左右孩子为空的就输出深度。

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        queue<TreeNode *> que; // 保存未“访问”的节点
        if (root != nullptr) que.push(root);

        int depth = 0;
        
        while (!que.empty()) {
            // 此为新的深度
            depth++;

            // 当前一层节点数
            int layer_size = que.size();
            for (int i = 0; i < layer_size; i++) {
                // 获取节点
                TreeNode *cur = que.front();
                que.pop();

                if (cur->left == nullptr && cur->right == nullptr) return depth;

                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
        } // 当队列为空终止

        return depth;
    }
};
```



### 完全二叉树的节点个数

题目：222

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 1~ 2^h 个节点。

思路1：遍历所有节点统计个数，可以采用递归或者迭代法。

代码略。



作者的思路：采用完全二叉树的思路：需要判断是否为满二叉树（根据左右结点深度是否一致，左子树一直遍历左节点，右子树一直遍历右节点）

在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树。如图：

<img src="222-1.jpg" alt="img" style="zoom: 33%;" />

在完全二叉树中，如果递归向左遍历的深度不等于递归向右遍历的深度，则说明不是满二叉树，如图：

<img src="222-2.jpg" alt="img" style="zoom:33%;" />

如果是满二叉树，就根据公式计算这个完全二叉树的结点数并返回， 2^树深度 - 1 ；

如果不是满二叉树，那就接着遍历返回左右子树的结点数之和+根节点的数量1

1.递归参数和返回值：参数为当前子树节点，返回值是当前子树节点的节点数

2.递归的终止条件：空结点不进行递归

3.递归的逻辑：使用while循环求当前节点左子树和右子树的深度，然后判断深度是否一致。

```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) return 0;

        // 求左子树和右子树的深度
        TreeNode *left = root->left;
        TreeNode *right = root->right;
        int left_h = 0;
        int right_h = 0;

        while (left) {
            left = left->left;
            left_h++;
        }
        while (right) {
            right = right->right;
            right_h++;
        }
        
        // 如果左子树左深度等于右子树右深度
        if (left_h == right_h) return (2 << left_h) - 1;
        else return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

时间复杂度：O(log n × log n)，

空间复杂度：O(log n)，递归的调用栈

### 平衡二叉树

题目：110

给定一个二叉树，判断它是否是 平衡二叉树 

明确概念：

- 二叉树节点的深度：指从**根节点**到**该节点**的最长简单路径边的条数。
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

因为求深度可以从上到下去查 所以需要**前序遍历**（中左右），而高度只能从下到上去查，所以只能**后序遍历**（左右中）

在题目求二叉树**最大深度**时采用的是后序遍历，求的是根节点的高度，也就是高度。



思路1：递归。平衡二叉树就是左右子树高度不能相差1，因此采用后序遍历。

1.递归的参数和返回值：参数是一个子树根结点，返回值是子树高度，如果不是平衡子树就返回-1

2.递归的终止：当遇到空结点时。

3.递归的逻辑：求左右子树高度，注意这里如果子树高度为-1，说明子树不是平衡的，那么以这个根节点的树也不是平衡的。

判断左右子树高度是否相差1以内。

```c++
class Solution {
public:
    int CountHeight(TreeNode *cur) {
        // 递归终止
        if (cur == nullptr) return 0;

        // 求左右子树高度
        // 如果某一棵左右子树不平衡则该子树页不平衡
        int left_h = CountHeight(cur->left);
        if (left_h == - 1) return -1;
        int right_h = CountHeight(cur->right);
        if (right_h == -1) return -1;
        
        
        if (abs(left_h - right_h) > 1) return -1;
        else return max(left_h, right_h) + 1;
    }

    bool isBalanced(TreeNode* root) {
        if (CountHeight(root) != -1) return true;
        else return false;
    }
};
```

思路2：迭代法：使用一个函数计算当前节点的深度，然后使用后序遍历判断每个节点的左右子树深度是否一致。

存在很多冗余计算，因此复杂度很高。



### 二叉树的所有路径

题目：257. 二叉树的所有路径

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

思路：前序遍历可以记录从根节点到相应节点的路径，同时这里明显有回溯的操作，遍历完左孩子之后还需要删除左孩子，然后添加右孩子，所以使用递归更方便。

1.递归的参数和返回值：参数为当前根节点，一个用于装目前路径的数组path。无返回值

2.递归的终止条件：空节点不会进入递归

3.递归的逻辑：先将当前根节点加入路径，然后判断当前根节点左右孩子是否为空，如果为空说明遇到叶子节点，应该记录此时路径。尝试遍历左孩子，注意会将左孩子加入节点，尝试完毕之后需要弹出左孩子。右孩子同理。

```c++
class Solution {
public:
    vector<string> result;
    void PreTraversal(TreeNode *cur, vector<int> &path) {
        // 空结点不进入递归
        // 先将当前根节点加入路径
        path.push_back(cur->val);

        // 判断左右孩子是否都为空
        if (cur->left == nullptr && cur->right == nullptr) {
            // 将路径转换为string
            string tmp;
            for (int i = 0; i < path.size()-1; i++) {
                tmp += to_string(path[i]);
                tmp += "->";
            }
            tmp += to_string(path[path.size()-1]);
            result.push_back(tmp);
        }

        // 尝试遍历左孩子
        if (cur->left) {
            PreTraversal(cur->left, path);
            // 回溯
            path.pop_back();
        }
        // 尝试遍历右孩子
        if (cur->right) {
            PreTraversal(cur->right, path);
            path.pop_back();
        }
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        // 空结点不进行递归
        if (root == nullptr) return result;

        vector<int> path;
        PreTraversal(root, path);

        return result;
    }
};
```



思路2：使用迭代，一个栈用于模拟前序遍历，一个栈用于装从根结点到当前节点的路径。









### 阶段总结2

对称二叉树：递归比较两个子树的外侧和内侧，或者迭代每次处理对应的两个节点。

二叉树最大深度：深度指的是从根节点到当前节点的结点个数（适合使用前序遍历，因为首先处理处理当前结点深度），高度指的是从当前结点到叶子结点的结点个数（适合后序遍历，先处理子树的高度再处理根的高度）

二叉树最小深度：需要注意的是深度指的是到叶子结点，即左右孩子结点都为空。

完全二叉树结点数量：采用递归方式，如果是满二叉树，即左孩子一直向左遍历的深度和右孩子一直向右遍历的深度一样，就利用公式计算，否则就统计左右孩子加上根节点。

是否为平衡二叉树：递归求左右孩子的高度，判断是否相差1

找寻所有路径：前序遍历递归















