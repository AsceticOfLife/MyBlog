---
title: 【代码随想录】二叉树
keywords: '代码随想录, 二叉树'
categories:
  - 代码随想录
tags:
  - 刷题记录
  - 代码随想录
  - C++
typora-root-url: 【代码随想录】二叉树
abbrlink: 1225167916
date: 2024-01-16 10:26:57
---

### 二叉树简介

基础概念：满二叉树、完全二叉树、二叉查找树（搜索树）、平衡二叉搜索树

**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

二叉树存储结构：顺序存储（如果双亲结点是i那么左孩子是2\*i + 1，右孩子是2\*i + 2)和链式存储

二叉树的遍历方式：

- 深度优先遍历

  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）

- 广度优先遍历

  - 层次遍历（迭代法）

  **栈其实就是递归的一种实现结构**，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。

  广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

  二叉树节点定义：

  ```c++
  struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };
  ```

<!-- more -->

### 二叉树递归遍历

递归的方法：

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

144.二叉树的前序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void PreTraversal(TreeNode *cur, vector<int> &result) {
        // 终止条件
        if (cur == nullptr) return;

        // 首先处理当前根节点
        result.push_back(cur->val);
        // 然后处理左右孩子节点
        PreTraversal(cur->left, result);
        PreTraversal(cur->right, result);
    }

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result; // 结果数组
        PreTraversal(root, result);
        
        return result;
    }
};
```

另一种写法：在进入递归之前就判断是否为空结点。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void PreTraversal(TreeNode *cur, vector<int> &result) {
        // 终止条件
        // 空结点不会进入该函数

        // 首先处理当前根节点
        result.push_back(cur->val);
        // 然后处理左右孩子节点
        if (cur->left) PreTraversal(cur->left, result);
        if (cur->right) PreTraversal(cur->right, result);
    }


    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result; // 结果数组
        if (root) PreTraversal(root, result);
        
        return result;
    }
};
```

145.二叉树的后序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void PostTraversal(TreeNode *cur, vector<int> &result) {
        // 终止条件
        if (cur == nullptr) return;

        // 先处理左右孩子
        PostTraversal(cur->left, result);
        PostTraversal(cur->right, result);

        // 最后处理当前根节点
        result.push_back(cur->val);
    }

    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        PostTraversal(root, result);

        return result;
    }
};
```



94.二叉树的中序遍历

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void InTraversal(TreeNode *cur, vector<int> &result) {
        // 终止条件
        if (cur == nullptr) return;

        // 先处理左孩子
        InTraversal(cur->left, result);

        // 接着处理当前根节点
        result.push_back(cur->val);

        // 最后处理右孩子
        InTraversal(cur->right, result);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        InTraversal(root, result);

        return result;
    }
};
```



### 二叉树迭代遍历

前序遍历：使用栈实现

前序处理的方式是：根、左、右，因此向将根节点放入栈、右孩子进入栈、最后左孩子进入栈。

（注意这里为了减少将节点从栈中拿出还需要判断是否为空节点的操作，空结点不入栈，对应了上面的前序遍历第二种写法，在入栈前判断左右孩子是否为空）

一次循环所做的操作与一次递归函数基本类似，先处理从栈中取出的根节点，然后将右、左孩子入栈。

注意访问顺序和处理顺序，访问顺序就是第一次遇到这个节点，处理顺序是真正操作节点的值val。

**访问和处理的顺序是一致的。**前序遍历的访问顺序是中左右，处理的顺序也是中左右。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode *> st; // 用于存放节点
        vector<int> result;

        if (root) st.push(root);
        while (!st.empty()) {
            // 首先取出栈顶节点
            TreeNode *cur = st.top();
            st.pop();
            // 处理栈顶节点
            result.push_back(cur->val);

            // 访问左右孩子节点，注意顺序
            if (cur->right) st.push(cur->right);
            if (cur->left) st.push(cur->left);
        }

        return result;
    }   
};
```



中序遍历：处理顺序是中左右，但是**访问顺序**是一直访问到左孩子结点为空时才会处理中结点，接着以右孩子作为新的根结点进行访问。

因此借助指针来**访问**，使用栈**处理**。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode *> st; // 处理节点顺序
        vector<int> result;
        TreeNode *cur = root; // 访问节点顺序
        // 当访问节点为空并且栈空时所有节点都已处理
        while (cur != nullptr || !st.empty()) {
            if (cur != nullptr) {
                // 当前访问节点不是空结点
                st.push(cur);
                // 继续向左访问
                cur = cur->left;
            } else {
                // 当前访问节点是空结点
                // 说明向左访问到头
                // 处理根节点
                cur = st.top();
                st.pop();
                result.push_back(cur->val);

                // 接着访问右孩子
                cur = cur->right;
            }
        } // end while

        return result;
    }
};
```

后序遍历：

将前序遍历稍微修改：前序遍历是中左右->中右左->逆序->左右中

即逆序。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode *> st;
        vector<int> result;
        if (root) st.push(root);
        while (!st.empty()) {
            TreeNode *cur = st.top();
            st.pop();
            // 处理顺序改为中、右、左
            result.push_back(cur->val);

            // 先左后右入栈，这样处理的时候就是先右后左
            if (cur->left) st.push(cur->left);
            if (cur->right) st.push(cur->right);
        }
        // 逆序处理
        reverse(result.begin(), result.end());

        return result;
    }
};
```

### 二叉树统一迭代法

以中序遍历为例，**将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**要处理的结点放入栈之后，需要加上一个空结点。

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode *> st;
        vector<int> res;

        // 根节入栈
        if (root != nullptr) st.push(root);

        while (!st.empty()) {
            TreeNode *node = st.top();
			
            // 非空节点进行访问操作
            if (node != nullptr) {
                // 先将这个结点弹出
                st.pop();

                // 尝试将右孩子入栈
                if (node->right != nullptr) st.push(node->right);
                // 将中结点入栈，并且中间结点已经访问过，作为下一次处理的结点需要标记
                st.push(node);
                st.push(nullptr);

                // 最后将左孩子入栈
                if (node->left != nullptr) st.push(node->left);
            } else {
                // 如果栈顶是空指针，说明下一个是需要处理的结点
                st.pop();

                // 将需要处理的结点假如列表
                res.push_back(st.top()->val);
                st.pop();
            }
        }

        return res;
    }
};
```

前序遍历：

```c++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        // 使用栈保存未访问的结点
        stack<TreeNode *>st;
        vector<int> res;

        if (root == nullptr) return res;
        // 首先将根结点入栈
        st.push(root);

        while (!st.empty()) {
            TreeNode *node = st.top();

            if (node != nullptr) {
                st.pop();

                // 右、左孩子入栈
                if (node->right) st.push(node->right);
                if (node->left) st.push(node->left);
                
                st.push(node);
                st.push(nullptr);
            } else {
                st.pop();
                res.push_back(st.top()->val);
                st.pop();
            }
        }

        return res;
    }
};
```

后序遍历：

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        // 使用栈保存未访问的结点
        stack<TreeNode *>st;
        vector<int> res;

        if (root == nullptr) return res;
        // 首先将根结点入栈
        st.push(root);

        while (!st.empty()) {
            TreeNode *node = st.top();

            if (node != nullptr) {
                st.pop();
                st.push(node);
                st.push(nullptr);
                
                // 左、右孩子入栈
                if (node->left) st.push(node->left);
                if (node->right) st.push(node->right);
            } else {
                st.pop();
                res.push_back(st.top()->val);
                st.pop();
            }
        }

        return res;
    }
};
```



### 二叉树层序遍历

层序遍历就是每次从左到右遍历同一个深度的节点，类似于广度优先搜索，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**

思路1：(类比于上面的迭代法中使用空指针作为标记)是为每层后面加一个空结点标识，当遇到空结点说明上一层处理完了，同时也要在队列中加一个空结点标识现在队列中是一层。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        vector<int> temp;
        queue<TreeNode *> qu;
        // 每一层用一个空结点区分
        if (root != nullptr) {
            qu.push(root);
            qu.push(nullptr);
        } 
        
        while (qu.size() > 1 || qu.front() != nullptr) {
            // 取出队首元素
            TreeNode *node = qu.front();
            if (node != nullptr) {
                // 不为空层数不增加
                qu.pop();

                // 处理结点
                temp.push_back(node->val);

                // 并尝试将左右结点队
                if (node->left) qu.push(node->left);
                if (node->right) qu.push(node->right);
            } else {
                // 当队首元素为null说明这一层已经结束
                // 层数加1
                // 并且该层的孩子们（也就是下一层）也都入队，再加一个空结点
                qu.pop();
                res.push_back(temp);
                temp = vector<int>();
                qu.push(nullptr);
            }
        }
        if (temp.size() != 0) res.push_back(temp);

        return res;
    }
};
```

作者的思路1：（迭代法）当队列不为空时，每次处理一层，使在每次循环最开始记录当前队列多少元素，即为当前层数。然后使用for循环处理这size个结点即可。

还是一样空结点不入队，否则每次取出来节点还需要判断是否为空结点。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode *> que;
        vector<vector<int>> result;
        
        if (root) que.push(root);
        while (!que.empty()) {
            int nums_layer = que.size();
            // 处理这一层的所有节点
            vector<int> temp(nums_layer); // 该层所有节点
            for (int i = 0; i < nums_layer; i++) {
                // 取出节点
                TreeNode *cur = que.front();
                que.pop();

                // 处理节点
                temp[i] = cur->val;

                // 访问左右孩子
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            // 将该层结果保存
            result.push_back(temp);
        }

        return result;
    }
};
```



作者的思路2：使用深度优先遍历，递归的方式，每次处理完根节点之后，接着递归处理左右孩子。

递归参数：当前根结点，保存访问记录的列表，当前深度（因为一层使用一个列表表示，因此需要知道当前深度应该加到哪个列表中）

递归终止条件：当前根结点为空

一层递归逻辑：处理当前根结点，接着处理左右孩子。

```c++
class Solution {
public:
    void order(TreeNode* cur, vector<vector<int>>& result, int depth) {
        if (cur == nullptr) return;
        if (result.size() == depth) result.push_back(vector<int>());
        result[depth].push_back(cur->val);
        order(cur->left, result, depth + 1);
        order(cur->right, result, depth + 1);
    }
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        int depth = 0;
        order(root, result, depth);
        return result;
    }
};
```

题目：

102.二叉树的层序遍历

与上面的代码一样



107.二叉树的层次遍历II

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

思路：自上而下层序遍历之后逆序。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode *> que;
        vector<vector<int>> result;
        // 层序遍历
        if (root) que.push(root);
        while (!que.empty()) {
            int layer_nums = que.size(); // 该层节点数目
            vector<int> layer_vals(layer_nums); // 当前一层所有节点
            for (int i = 0; i < layer_nums; i++) {
                TreeNode *cur = que.front();
                que.pop();
                // 处理当前根节点
                layer_vals[i] = cur->val;

                // 左右孩子入队
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            // 将当前一层存储
            result.push_back(layer_vals);
        }
        reverse(result.begin(), result.end());

        return result;
    }
};
```



199.二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<img src="199.tree.jpg" alt="199.tree" style="zoom:67%;" />

```c++
输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
```

思路：右视图就是层序遍历的每一层最后一个元素。

```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> result;
        // 层序遍历
        if (root)
            que.push(root);
        while (!que.empty()) {
            int layer_nums = que.size(); // 该层节点数目

            layer_nums--; // 剩余最后一个元素
            for (int i = 0; i < layer_nums; i++) {
                TreeNode* cur = que.front();
                que.pop();
                // 处理当前根节点
                // 什么都不做

                // 左右孩子入队
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            // 将最后一个元素保留
            TreeNode* cur = que.front();
            que.pop();
            result.push_back(cur->val);
            // 左右孩子入队
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
        }

        return result;
    }
};
```



637.二叉树的层平均值

给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。

思路：层序遍历求每一层的平均值。

需要注意的是值的范围。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode *> que;
        vector<double> result;
        // 层序遍历
        if (root) que.push(root);
        while (!que.empty()) {
            int layer_nums = que.size(); // 该层节点数目
            double sum = 0; // 该层总和
            for (int i = 0; i < layer_nums; i++) {
                TreeNode *cur = que.front();
                que.pop();
                // 处理当前根节点
                sum += cur->val;

                // 左右孩子入队
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            // 将当前一层平均值存储
            result.push_back(sum / layer_nums);
        }

        return result;
    }
};
```



429.N叉树的层序遍历

给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。

思路：与层序遍历基本相同，唯一区别是每个节点的孩子入队时，将N个节点都入队。

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        queue<Node *> que;
        vector<vector<int>> result;
        // 层序遍历
        if (root) que.push(root);
        while (!que.empty()) {
            int layer_nums = que.size(); // 该层节点数目

            vector<int> layer_vals(layer_nums); // 当前一层所有节点
            for (int i = 0; i < layer_nums; i++) {
                Node *cur = que.front();
                que.pop();
                // 处理当前根节点
                layer_vals[i] = cur->val;

                // 所有孩子入队
                for (Node *child : cur->children) 
                    if (child) que.push(child);

            }
            // 将当前一层存储
            result.push_back(layer_vals);
        }

        return result;
    }
};
```

515.在每个树行中找最大值

思路：层序遍历每一行求最大值。与求平均值类似。



116.填充每个节点的下一个右侧节点指针

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

<img src="116.png" alt="116" style="zoom:50%;" />

思路：层序遍历会取出每一层所有的节点，因此除了对第一个的处理是保存当前next指针外，其余均零上一个的next指针指向自己并更新指针。每一层循环结束令最后一个节点的next指针指向空。

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        queue<Node *> que;
        if (root) que.push(root);
        // 层序遍历二叉树
        while (!que.empty()) {
            int layer_nums = que.size();
            
            // 对本层第一个特殊处理
            Node *cur = que.front();
            que.pop();
            Node **pre = &(cur->next); // 保存指向next指针的指针
            // 当前节点左右孩子入队
            if (cur->left) que.push(cur->left);
            if (cur->right) que.push(cur->right);
            --layer_nums;

            // 处理剩下的节点
            while (layer_nums--) {
                cur = que.front();
                que.pop();
                // 令前一个节点的next指针指向当前节点
                *pre = cur;
                // 更新前一个节点的next指针为当前节点的next指针
                pre = &(cur->next);

                // 当前节点左右孩子入队
                if (cur->left) que.push(cur->left);
                if (cur->right) que.push(cur->right);
            }
            // 处理最后一个节点的next指针
            *pre = nullptr;
        }

        return root;
    }
};
```



117.填充每个节点的下一个右侧节点指针II

给定一个二叉树：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。

初始状态下，所有 next 指针都被设置为 `NULL` 。

思路：这道题与上一题的区别是：上一题是完美二叉树。对于完美二叉树来说，其节点位置都是可以预知的。本题使用层序遍历依然可解。



104.二叉树的最大深度

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

思路：第一层也就是根节点所在一层的深度是1，下面每增加一层深度加1。其实可以看作是层序遍历的每一层的次数。因此每增加一层加1即可。

这里不再给出代码。



111.二叉树的最小深度

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

思路：上一题必须遍历完所有的节点才能知道谁是最远的叶子节点，该题层序遍历时由近及远进行遍历，只要当前层有叶子节点就可以提前返回当前层数。

具体实现就是：与上一题一样使用一个变量记录当前层数，然后在处理当前节点时，如果左右孩子均为空（说明是叶子节点）立即返回当前层数。

### 翻转二叉树

题目：226

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

<img src="226.jpg" alt="226" style="zoom:50%;" />

思路：遍历左右结点，把节点的左右孩子互换即可。

层序遍历可以实现。

递归法：前序、后序遍历都可以，中序遍历不可以，这是因为中序先处理左孩子，再处理中间节点，处理中间结点时左右孩子互换，如果再处理右孩子那么右孩子是之前处理的左孩子。

迭代法：前、中、后序遍历都可以。这里的中序遍历可以是因为采用标记法处理节点时，即使处理的是中间节点，互换了左右孩子，下一次处理的节点是从栈中取出，不用担心因当前节点互换影响处理顺序。

这里给出迭代法的中序遍历。

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode *> st;
        if (root) st.push(root);

        // 采用中序法遍历
        // 应该处理的节点后面是一个空结点
        while (!st.empty()) {
            TreeNode *cur = st.top();
            st.pop();
            if (cur != nullptr) {
                // 如果不是空结点说明应该遍历
                if (cur->right) st.push(cur->right);

                // 添加中间节点和一个空结点
                // 表示下一次应该处理
                st.push(cur);
                st.push(nullptr);

                if (cur->left) st.push(cur->left);
            } else {
                // 如果是空结点说明栈顶是应该处理的节点
                cur = st.top();
                st.pop();
                // 交换左右节点
                swap(cur->left, cur->right);
            }
        }

        return root;
    }
};
```



### 阶段总结1

该部分首先介绍一下内容：

二叉树基本概念：包括满满二叉树、完全二叉树，以及二叉树的存储结构，定义方式等。

二叉树前中后递归遍历方法

二叉树前中后迭代遍历方法：由于中序遍历的访问和处理是不一致的（总是先访问到中间结点，才会访问左右孩子，但是处理的时候是先处理左孩子，再处理中间结点），所以需要一个标志（标识应该被处理）。后序遍历就是前序遍历稍微修改一下：中左右->中右左 这样范围访问之后再逆序即可。

二叉树前中后统一迭代遍历方法

二叉树层序遍历方法

















